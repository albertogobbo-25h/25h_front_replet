# Fluxo de Gest√£o de Assinatura - 25h.com.br

## Diagrama de Fluxo

```mermaid
flowchart TD
  subgraph UI
    A[Usu√°rio abre Tela: Gest√£o de Assinatura]
  end

  A --> B[public.listar_assinaturas incluir_historico?]
  B --> C{Tem assinaturas?}
  C -- N√£o --> D[Mostrar CTA: escolher plano<br/>public.listar_planos_assinatura false]
  C -- Sim --> E[Listar: Ativa, Aguardando Pagamento, Suspensa, Cancelada hist√≥rico]

  %% A√ß√µes na lista
  E --> F1[Pagar na Pendente]
  E --> F2[Mudar plano]
  E --> F3[Cancelar Ativa]
  E --> F4[Cancelar Pendente]
  E --> F5[Pagar mensalidade quando Suspensa]

  %% Pagar pendente
  F1 --> G1[Edge Function: iniciar_pagto_assinante<br/>cobranca_id, meio_pagamento]
  G1 --> H1[Retorna link da Pluggy para consentimento]
  H1 --> I1[Usu√°rio acessa link e autoriza pagamento]
  I1 --> J1[Pluggy processa e chama webhook]

  %% Mudar plano
  F2 --> G2[public.criar_nova_assinatura<br/>plano_id, periodicidade<br/>cria Assinatura Pendente + Cobran√ßa]
  G2 --> H2[Voltar √† lista: mostrar Ativa + Nova Pendente]

  %% Cancelamentos
  F3 --> V1[public.cancelar_assinatura<br/>assinatura_id<br/>‚ö†Ô∏è N√ÉO IMPLEMENTADO]
  F4 --> V2[public.cancelar_assinatura<br/>assinatura_id<br/>‚ö†Ô∏è N√ÉO IMPLEMENTADO]
  
  V1 --> G3[status = Cancelada]
  V2 --> G4[status = Cancelada<br/>cancelar cobran√ßa se Em aberto]

  %% Suspensa (vencida)
  F5 --> G5[public.criar_nova_assinatura<br/>novo ciclo<br/>cria Pendente + Cobran√ßa]

  %% N8N webhook
  subgraph Webhook
    I[N8N recebe confirma√ß√£o de pagamento<br/>Edge Function: webhook_status_cobranca]
    I --> J[app_internal.fn_processar_webhook_pagamento_saas<br/>payload]
    J --> K{Idempot√™ncia ok?}
    K -- n√£o --> L[200 already processed]
    K -- sim --> M[BEGIN]
    M --> N[Marcar cobran√ßa = Pago, set dthr_pagamento]
    N --> O{Existe assinatura ATIVA anterior?}
    O -- sim --> P[Cancelar assinatura ativa anterior]
    P --> Q[Ativar nova assinatura]
    O -- n√£o --> Q[Ativar nova assinatura]
    Q --> R[Calcular data_validade da nova]
    R --> S[COMMIT]
    S --> T[Notificar assinante]
  end

%% Regras de c√°lculo R
%% - Se havia ATIVA com validade futura: nova.data_inicio = antiga.data_validade + 1 dia; nova.data_validade = antiga.data_validade + per√≠odo
%% - Caso contr√°rio: nova.data_inicio = hoje; nova.data_validade = hoje + per√≠odo

%% Observa√ß√µes
%% - S√≥ deve existir, no m√°ximo, 1 assinatura "Aguardando pagamento" por assinante de cada vez regra implementada
%% - Cancelar Pendente deve cancelar a cobran√ßa vinculada se ainda "Em aberto"
%% - Idempot√™ncia do webhook baseada em chave √∫nica por evento do gateway
```

## Regras de neg√≥cio essenciais

- **Coexist√™ncia**: pode haver uma assinatura ATIVA e, simultaneamente, uma nova PENDENTE (mudan√ßa de plano ou renova√ß√£o).
- **Ativa√ß√£o por pagamento**: ao confirmar pagamento, a PENDENTE vira ATIVA e a antiga ATIVA (se houver) √© cancelada.
- **Proje√ß√£o de validade**: 
  - Se h√° assinatura ATIVA **n√£o-gratuita**: nova validade = antiga.data_validade + per√≠odo
  - Se h√° assinatura ATIVA **gratuita** ou nenhuma: nova validade = hoje + per√≠odo
- **Cria√ß√£o de assinatura**: assinante pode criar nova assinatura a qualquer momento (gratuito expirado ou n√£o).
- **Cancelamento**: assinante pode cancelar ATIVA ou PENDENTE; ao cancelar PENDENTE, cancelar cobran√ßa em aberto.
- **Suspensa**: quando vence; usu√°rio pode iniciar novo ciclo gerando PENDENTE + cobran√ßa.
- **Idempot√™ncia**: webhook deve ser idempotente (repeti√ß√µes retornam 200 sem efeitos colaterais).

## Fun√ß√µes Backend - Refer√™ncia Completa

### üìã **1. Listar Planos de Assinatura**

**Fun√ß√£o:** `public.listar_planos_assinatura(p_incluir_gratuito BOOLEAN)`

**Status:** ‚úÖ Implementado

**Descri√ß√£o:** Lista todos os planos de assinatura dispon√≠veis

**Par√¢metros:**
- `p_incluir_gratuito` (default: `true`): Se deve incluir planos gratuitos na listagem

**Retorno:** `TABLE` com colunas:
```sql
id SMALLINT,
titulo TEXT,
descricao TEXT,
ind_gratuito BOOLEAN,
valor_mensal NUMERIC(10, 2),
valor_anual NUMERIC(10, 2),
valor_mensal_com_desconto NUMERIC(10, 2),
valor_anual_com_desconto NUMERIC(10, 2),
limite_clientes_ativos SMALLINT,
dias_degustacao SMALLINT,
features JSONB
```

**Exemplo de uso (Frontend):**
```typescript
// Listar apenas planos pagos (para upgrade)
const { data: planos } = await supabase
  .rpc('listar_planos_assinatura', { p_incluir_gratuito: false })

// Listar todos os planos
const { data: todosPlanos } = await supabase
  .rpc('listar_planos_assinatura')
```

---

### üìã **2. Listar Assinaturas do Assinante**

**Fun√ß√£o:** `public.listar_assinaturas(p_incluir_historico BOOLEAN)`

**Status:** ‚úÖ Implementado

**Descri√ß√£o:** Lista assinaturas do assinante logado (ATIVA, PENDENTE, SUSPENSA e opcionalmente CANCELADA)

**Par√¢metros:**
- `p_incluir_historico` (default: `false`): Se deve incluir assinaturas CANCELADAS

**Retorno:** `JSONB`
```json
{
  "status": "OK | ERROR",
  "code": "ERROR_CODE (se erro)",
  "message": "Mensagem de erro (se erro)",
  "data": [
    {
      "assinatura_id": "uuid",
      "status": "ATIVA | AGUARDANDO_PAGAMENTO | SUSPENSA | CANCELADA",
      "periodicidade": "MENSAL | ANUAL",
      "data_inicio": "date",
      "data_validade": "date",
      "plano": {
        "id": "number",
        "titulo": "string",
        "ind_gratuito": "boolean"
      },
      "cobranca_em_aberto": {
        "id": "uuid",
        "valor": "number",
        "data_vencimento": "date",
        "status": "EM_ABERTO",
        "link_pagamento": "string | null"
      } | null
    }
  ]
}
```

**Exemplo de uso (Frontend):**
```typescript
// Listar assinaturas ativas/pendentes/suspensas
const { data } = await supabase
  .rpc('listar_assinaturas', { p_incluir_historico: false })

// Incluir hist√≥rico (canceladas)
const { data: comHistorico } = await supabase
  .rpc('listar_assinaturas', { p_incluir_historico: true })
```

---

### üìã **3. Criar Nova Assinatura**

**Fun√ß√£o:** `public.criar_nova_assinatura(p_plano_id SMALLINT, p_periodicidade enum_assinatura_periodicidade)`

**Status:** ‚úÖ Implementado

**Descri√ß√£o:** Cria nova assinatura (migra√ß√£o de gratuito para pago ou upgrade/renova√ß√£o)

**Par√¢metros:**
- `p_plano_id`: ID do plano escolhido
- `p_periodicidade` (default: `'MENSAL'`): Periodicidade da assinatura (`'MENSAL'` ou `'ANUAL'`)

**Valida√ß√µes:**
- ‚úÖ Assinante deve ter dados completos (nome, cpf_cnpj, tipo_pessoa, email)
- ‚úÖ Plano deve existir, estar ativo e n√£o ser gratuito
- ‚úÖ N√£o pode haver outra assinatura AGUARDANDO_PAGAMENTO
- ‚úÖ Plano deve suportar a periodicidade escolhida

**Retorno:** `JSONB`
```json
{
  "status": "OK | ERROR",
  "code": "ERROR_CODE (se erro)",
  "message": "Mensagem",
  "data": {
    "assinatura": {
      "id": "uuid",
      "status": "AGUARDANDO_PAGAMENTO",
      "data_inicio": "date",
      "data_validade": "date",
      "periodicidade": "MENSAL | ANUAL"
    },
    "plano": {
      "id": "number",
      "titulo": "string",
      "descricao": "string"
    },
    "cobranca": {
      "id": "uuid",
      "valor": "number",
      "data_vencimento": "date",
      "status": "EM_ABERTO"
    },
    "assinatura_atual": {
      "id": "uuid",
      "plano_titulo": "string",
      "data_validade": "date",
      "status": "ATIVA"
    } | null
  }
}
```

**L√≥gica de C√°lculo de Datas:**
- Se h√° assinatura ATIVA n√£o-gratuita: `nova.data_inicio = antiga.data_validade + 1 dia`
- Sen√£o: `nova.data_inicio = hoje`
- `nova.data_validade = data_inicio + per√≠odo - 1 dia`

**Exemplo de uso (Frontend):**
```typescript
const { data } = await supabase
  .rpc('criar_nova_assinatura', {
    p_plano_id: 2,
    p_periodicidade: 'MENSAL'
  })

if (data.status === 'OK') {
  const cobrancaId = data.data.cobranca.id
  // Pr√≥ximo passo: iniciar pagamento
}
```

---

### üí≥ **4. Iniciar Pagamento de Cobran√ßa**

**Fun√ß√£o:** **Edge Function** `iniciar_pagto_assinante`

**Status:** ‚úÖ Implementado

**Descri√ß√£o:** Inicia processo de pagamento via Pluggy (N8N)

**M√©todo:** `POST`

**URL:** `/functions/v1/iniciar_pagto_assinante`

**Headers:**
```
Authorization: Bearer {USER_JWT_TOKEN}
Content-Type: application/json
```

**Body:**
```json
{
  "cobranca_id": "uuid",
  "meio_pagamento": "OPF_PIX_IMEDIATO | OPF_PIX_AUTOMATICO"
}
```

**Valida√ß√µes:**
- ‚úÖ Usu√°rio autenticado
- ‚úÖ Cobran√ßa existe e pertence ao assinante
- ‚úÖ Cobran√ßa est√° com status `EM_ABERTO`
- ‚úÖ Assinatura est√° com status `AGUARDANDO_PAGAMENTO`
- ‚úÖ Dados do assinante completos (nome, email, cpf_cnpj, tipo_pessoa, whatsapp)
- ‚úÖ Gateway status permite nova tentativa

**Comportamento:**
1. Valida dados do assinante e cobran√ßa
2. Busca ou cria pagador no Pluggy (fallback autom√°tico)
3. Cria requisi√ß√£o de pagamento via N8N
4. Registra inicializa√ß√£o no banco (transa√ß√£o at√¥mica)
5. Retorna link de pagamento da Pluggy

**Retorno:** `JSONB`
```json
{
  "status": "OK | ERROR | WARNING",
  "message": "string",
  "data": {
    "pluggy": {
      "id": "string",
      "paymentUrl": "string",
      "status": "string",
      "description": "string"
    },
    "database": {
      "initialization": {},
      "cobranca_id": "uuid",
      "assinatura_id": "uuid",
      "request_id": "string",
      "atomic_transaction": true
    }
  },
  "warnings": ["string"] // se houver
}
```

**Exemplo de uso (Frontend):**
```typescript
const { data, error } = await supabase.functions.invoke(
  'iniciar_pagto_assinante',
  {
    body: {
      cobranca_id: 'uuid-da-cobranca',
      meio_pagamento: 'OPF_PIX_AUTOMATICO'
    }
  }
)

if (data.status === 'OK') {
  const paymentUrl = data.data.pluggy.paymentUrl
  window.open(paymentUrl, '_blank') // Redirecionar para Pluggy
}
```

---

### ü™ù **5. Webhook de Status de Pagamento**

**Fun√ß√£o:** **Edge Function** `webhook_status_cobranca`

**Status:** ‚úÖ Implementado

**Descri√ß√£o:** Recebe notifica√ß√µes de status de pagamento do Pluggy via N8N

**M√©todo:** `POST`

**URL:** `/functions/v1/webhook_status_cobranca`

**Headers:**
```
X-N8N-Token: {N8N_API_KEY}
Content-Type: application/json
```

**Body:**
```json
{
  "eventId": "string",
  "event": "string",
  "paymentRequestId": "string",
  "paymentIntentId": "string",
  "automaticPixPaymentId": "string",
  "status": "SUCCESS | FAILED | EXPIRED | ...",
  "endToEndId": "string"
}
```

**Comportamento:**
1. Valida token do N8N
2. Identifica contexto (SAAS ou ASSINANTE)
3. Delega para `app_internal.fn_processar_webhook_pagamento_saas()`
4. Fun√ß√£o interna processa (transa√ß√£o at√¥mica):
   - Verifica idempot√™ncia
   - Atualiza status da cobran√ßa
   - Se pagamento confirmado: ativa nova assinatura e cancela anterior
   - Calcula data de validade
   - Registra log de eventos

**Idempot√™ncia:** Baseada em `eventId` √∫nico

**Retorno:**
```json
{
  "status": "OK | ERROR",
  "message": "string",
  "data": {}
}
```

---

### üóëÔ∏è **6. Cancelar Assinatura**

**Fun√ß√£o:** `public.cancelar_assinatura(p_assinatura_id UUID)`

**Status:** ‚ùå **N√ÉO IMPLEMENTADO** (existe apenas valida√ß√£o interna)

**Descri√ß√£o:** Cancela assinatura e suas cobran√ßas em aberto

**Fun√ß√£o Auxiliar (implementada):**
- `app_internal.fn_validar_cancelamento_assinatura(p_assinatura_id UUID)` ‚úÖ Implementado

**Valida√ß√µes Implementadas:**
- ‚úÖ Assinatura n√£o est√° cancelada
- ‚úÖ Verifica PIX Autom√°tico ativo (mandate)
- ‚úÖ Valida deadline de cobran√ßas PIX Autom√°tico (22h do dia anterior)
- ‚úÖ Valida status de cobran√ßas PIX Imediato

**Retorno da Valida√ß√£o:** `JSONB`
```json
{
  "pode_cancelar": "boolean",
  "precisa_pluggy": "boolean",
  "tem_pix_automatico": "boolean",
  "payment_request_id": "string | null",
  "total_cobrancas_problematicas": "number",
  "total_cobrancas_cancelaveis": "number",
  "cobrancas_problematicas": [],
  "cobrancas_cancelaveis": [],
  "mensagem": "string"
}
```

**‚ö†Ô∏è PENDENTE:** Implementar fun√ß√£o p√∫blica `public.cancelar_assinatura()` que:
1. Chama `fn_validar_cancelamento_assinatura()`
2. Se `pode_cancelar = false`, retorna erro
3. Se `precisa_pluggy = true`:
   - Chama N8N para cancelar mandate/cobran√ßas na Pluggy
   - Aguarda confirma√ß√£o
4. Atualiza status da assinatura para `CANCELADA`
5. Cancela cobran√ßas em aberto

---

### üë§ **7. Gerenciar Dados do Assinante**

#### 7.1 Obter Dados

**Fun√ß√£o:** `public.obter_dados_assinante()`

**Status:** ‚úÖ Implementado

**Retorno:** `JSONB`
```json
{
  "status": "OK | ERROR",
  "data": {
    "id": "uuid",
    "nome": "string",
    "nome_fantasia": "string",
    "cpf_cnpj": "string",
    "tipo_pessoa": "FISICA | JURIDICA",
    "email": "string",
    "whatsapp": "string",
    "rua": "string",
    "numero": "string",
    "complemento": "string",
    "bairro": "string",
    "cidade": "string",
    "uf": "string",
    "cep": "string"
  }
}
```

#### 7.2 Atualizar Dados

**Fun√ß√£o:** `public.atualizar_dados_assinante(...)`

**Status:** ‚úÖ Implementado

**Par√¢metros:** Todos opcionais (atualiza apenas os fornecidos)
- `p_nome TEXT`
- `p_nome_fantasia TEXT`
- `p_rua TEXT`
- `p_numero TEXT`
- `p_complemento TEXT`
- `p_bairro TEXT`
- `p_cidade TEXT`
- `p_uf CHAR(2)`
- `p_cep VARCHAR(10)`
- `p_cpf_cnpj VARCHAR(20)`
- `p_tipo_pessoa enum_tipo_pessoa`
- `p_email TEXT`
- `p_whatsapp TEXT`

**Valida√ß√µes:**
- ‚úÖ Email v√°lido
- ‚úÖ WhatsApp v√°lido (formato brasileiro)
- ‚úÖ CEP v√°lido
- ‚úÖ UF v√°lida
- ‚úÖ CPF/CNPJ consistente com tipo_pessoa

**Retorno:** `JSONB`
```json
{
  "status": "OK | ERROR",
  "message": "string",
  "data": {
    // dados atualizados
  }
}
```

---

## Resumo de Implementa√ß√£o

### ‚úÖ **Implementado e Funcionando:**
1. ‚úÖ `public.listar_planos_assinatura()` 
2. ‚úÖ `public.listar_assinaturas()`
3. ‚úÖ `public.criar_nova_assinatura()`
4. ‚úÖ **Edge Function** `iniciar_pagto_assinante`
5. ‚úÖ **Edge Function** `webhook_status_cobranca`
6. ‚úÖ `public.obter_dados_assinante()`
7. ‚úÖ `public.atualizar_dados_assinante()`
8. ‚úÖ `app_internal.fn_validar_cancelamento_assinatura()`
9. ‚úÖ `app_internal.fn_processar_webhook_pagamento_saas()`
10. ‚úÖ `app_internal.fn_crud_assinatura_*` (CRUD completo)
11. ‚úÖ `app_internal.fn_crud_assinatura_cobranca_*` (CRUD completo)

### ‚ùå **Pendente de Implementa√ß√£o:**
1. ‚ùå `public.cancelar_assinatura(p_assinatura_id)` ‚Äî **PRIORIDADE ALTA**
   - J√° tem valida√ß√£o implementada
   - Falta implementar a fun√ß√£o p√∫blica que orquestra o cancelamento
   - Precisa integrar com N8N/Pluggy para cancelar mandate e cobran√ßas

## Estado atual da implementa√ß√£o

### ‚úÖ Implementado:
- Estrutura b√°sica das tabelas `assinatura` e `assinatura_cobranca`
- Enums para status e periodicidade
- Fun√ß√µes CRUD b√°sicas para assinaturas e cobran√ßas
- Fun√ß√£o `listar_planos_assinatura()` para exibir planos dispon√≠veis
- Fun√ß√£o `fn_assinatura_ler_valida()` para validar assinatura atual
- Campo `id_cobranca_gateway` (equivale ao `gateway_payment_id`)
- **Constraint √∫nica**: M√°ximo 1 assinatura "Aguardando pagamento" por assinante
- **Auditoria padronizada**: Colunas `criado_por`, `criado_em`, `modificado_em`
- **Tipos de dados consistentes**: `TIMESTAMPTZ` para instantes, `DATE` para datas l√≥gicas
- **RLS unificado**: Todas as pol√≠ticas usam `app_internal.current_assinante_id()`

### üîÑ Pr√≥ximo passo:
- Implementar fun√ß√£o `criar_nova_assinatura()` para migra√ß√£o gratuito ‚Üí pago
- Implementar regras de neg√≥cio de coexist√™ncia e c√°lculo de datas

#### Fun√ß√£o `criar_nova_assinatura()` - Especifica√ß√£o:
```sql
CREATE OR REPLACE FUNCTION public.criar_nova_assinatura(
    p_plano_id SMALLINT,
    p_periodicidade public.enum_assinatura_periodicidade DEFAULT 'Mensal'
)
RETURNS JSONB
```

**Valida√ß√µes:**
1. Verificar se n√£o h√° assinatura pendente j√° existente
2. Validar se plano escolhido existe e est√° ativo
3. Verificar se assinante est√° autenticado

**A√ß√µes:**
1. Criar nova assinatura com status "Aguardando pagamento"
2. Calcular `data_inicio` e `data_validade` conforme regras:
   - **Se h√° assinatura ATIVA n√£o-gratuita**: nova.data_inicio = antiga.data_validade + 1 dia
   - **Se h√° assinatura ATIVA gratuita ou nenhuma assinatura**: nova.data_inicio = hoje
   - **data_validade**: data_inicio + per√≠odo do plano escolhido
3. Criar cobran√ßa vinculada com valor do plano
4. Retornar dados para frontend (IDs, valores, instru√ß√µes)

**Regras de neg√≥cio:**
- Assinante pode criar nova assinatura mesmo com plano gratuito expirado
- Se h√° assinatura ATIVA (gratuita ou paga), mant√©m ativa at√© nova ser paga
- C√°lculo de datas s√≥ considera assinatura anterior se for n√£o-gratuita

### ‚è≥ Para integra√ß√£o com N8N/Pluggy:
- `assinatura_cobranca` campos de integra√ß√£o: `gateway_consent_id`, `gateway_mandate_id` (opcional), `idempotency_key` (UNIQUE), `dthr_pagamento`
- `assinatura.gateway_consent_id` (TEXT): para Pix Autom√°tico
- RLS: assinante s√≥ acessa suas `assinatura` e `assinatura_cobranca`

## Melhorias de Performance Implementadas

### **Estrat√©gias de Identifica√ß√£o**
- **Tabelas de alto volume**: `assinatura` e `assinatura_cobranca` usam `BIGINT IDENTITY` para m√°xima performance
- **Tabelas de configura√ß√£o**: `cfg_planos_assinatura` usa `UUID` com `app_internal.gen_uuid_v7()` para ordenabilidade
- **Relacionamentos N:N**: `evento_cliente` e `evento_recorrente_cliente` com chave prim√°ria composta

### **Integridade de Dados**
- **Constraint √∫nica**: `usuario_funcao` com constraint √∫nica `(usuario_id, funcao)` para evitar duplicidades
- **√çndice √∫nico**: Assinaturas pendentes com √≠ndice √∫nico para prevenir m√∫ltiplas assinaturas em aberto por assinante
- **Auditoria padronizada**: Colunas de auditoria unificadas (`criado_por`, `criado_em`, `modificado_em`)

### **Seguran√ßa e Consist√™ncia**
- **RLS unificado**: Todas as pol√≠ticas RLS usam `app_internal.current_assinante_id()` para maior confiabilidade
- **Tipos de dados consistentes**: Padroniza√ß√£o de `TIMESTAMPTZ` para instantes e `DATE` para datas l√≥gicas
- **Limpeza de c√≥digo**: Remo√ß√£o de sobrecargas antigas de fun√ß√µes CRUD

### L√≥gica do gateway_consent_id (futuro):
- **Pix Autom√°tico**: preenchido em ambas as tabelas (assinatura + cobran√ßa)
- **Pix Imediato**: s√≥ na cobran√ßa, null na assinatura

## Observabilidade e confiabilidade

- Logs estruturados nas fun√ß√µes (cria√ß√£o/ativa√ß√£o/cancelamento) e no webhook.
- Auditoria de mudan√ßas de status (j√° coberta por triggers de auditoria, se habilitadas).
- M√©tricas: taxa de convers√£o PENDENTE->ATIVA, cancelamentos, falhas de pagamento.

## Integra√ß√£o com Gateway (Pagador/Recebedor)

- Recebedor (SaaS): j√° cadastrado manualmente no gateway; armazenado em `gateway_saas_recebedor` (provider, external_id, status?, metadata?).
- Pagador (Assinante): pode ser criado on-the-fly na mesma chamada de cria√ß√£o da cobran√ßa via N8N/Pluggy.
  - Tabela sugerida: `gateway_assinante_pagador` com colunas: `assinante_id` (FK), `gateway_payer_id` (TEXT UNIQUE), `provider` (TEXT/ENUM), `criado_em`, `atualizado_em`, `status?`, `metadata?`.
  - Fluxo: ao iniciar pagamento (POST), enviar `gateway_payer_id` se existir; se n√£o, enviar dados do pagador. O N8N cria o pagador no gateway e, em seguida, cria a cobran√ßa; a resposta retorna `gateway_payment_id` e o `gateway_payer_id`, que devem ser persistidos.
  - Relacionamento com cobran√ßas: cada `assinatura_cobranca` referencia o pagador implicitamente via `assinante_id`; opcional armazenar `gateway_payer_id` na cobran√ßa para auditoria.

Chamadas ao N8N (uma √∫nica chamada):
- Requisi√ß√£o: `{ cobranca: { valor, tipo_pagamento? }, pagador: { id? | dados_pessoais } }`
- Resposta: `{ gateway_payment_id, gateway_payer_id, gateway_consent_id? }`

Endere√ßamento nos endpoints:
- POST `/assinaturas` e POST `/pagamentos/:cobrancaId/...` devem garantir a exist√™ncia do pagador no gateway (create-if-missing) antes de criar consentimento ou iniciar pagamento.

### Conven√ß√£o de nomes (tabelas de gateway)

- `gateway_saas_recebedor`: id do recebedor do SaaS no provider.
- `gateway_assinante_pagador`: id do pagador do assinante no provider.
- `gateway_assinante_recebedor`: usar no futuro apenas se o assinante tamb√©m atuar como recebedor (marketplace/split).